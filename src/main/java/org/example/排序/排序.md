# 排序

### 1. 常见的排序算法

![在这里插入图片描述](../../../../resources/picture/常见的排序算法.png)

### 2. 算法的时间复杂度

#### 2.1 时间频度和时间复杂度

**时间频度T(n)**

一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。

**时间复杂度O(n)**

一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

在T(n)=4n²-2n+2中，就有f(n)=n²，使得T（n)/f(n)的极限值为4，那么O(f(n))，也就是时间复杂度为O(n²)

- 对于不是只有常数的时间复杂度忽略时间频度的系数、低次项常数

- 对于只有常数的时间复杂度，将常数看为1

#### 2.2 常见的时间复杂度

**常数阶 O(1)**

无论代码执行了多少行，只要没有循环等复杂的结构，时间复杂度都是O(1)

```java
int i = 1;
i++;
```

**对数阶O(log2n)**

此处i并不是依次递增到n，而是每次都以倍数增长。假设循环了x次后i大于n。则2x = n，x=log2n

```java
while(i < n) {
    i = i*2;
}
```

**线性阶O(n)**

这其中，循环体中的代码会执行n+1次，时间复杂度为O(n)

```java
for(int i = 0; i<n; i++) {
	i++;
}
```

**线性对数阶O(nlog2n)**

此处外部为一个循环，循环了n次。内部也是一个循环，但内部f循环的时间复杂度是log2n

所以总体的时间复杂度为线性对数阶O(nlog2n)

```java
for(int i = 0; i<n; i++) {
    j = 1;
	while(j<n) {
		j = j*2;
	}
}
```

**平方阶O(n2)**

```java
for(int i = 0; i<n; i++) {
	for(int j = 0; j<n; j++) {
		//循环体
	}
}
```

**立方阶O(n3)**

```java
for(int i = 0; i<n; i++) {
	for(int j = 0; j<n; j++) {
		for(int k = 0; k<n; k++) {
			//循环体
		}
	}
}
```

>可以看出平方阶、立方阶的复杂度主要是否循环嵌套了几层来决定的

### 3. 排序算法的时间复杂度

| 排序算法 | 平均时间 | 最差时间     | 稳定性 | 空间复杂度 | 备注                                         |
| -------- | -------- | ------------ | ------ | ---------- | -------------------------------------------- |
| 冒泡排序 | O(n2)    | O(n2)        | 稳定   | O(1)       | n较小时好                                    |
| 交换排序 | O(n2)    | O(n2)        | 不稳定 | O(1)       | n较小时好                                    |
| 选择排序 | O(n2)    | O(n2)        | 不稳定 | O(1)       | n较小时好                                    |
| 插入排序 | O(n2)    | O(n2)        | 稳定   | O(1)       | 大部分已有序时好                             |
| 基数排序 | O(n*k)   | O(n*k)       | 稳定   | O(n)       | 二维数组（桶）、一维数组（桶中首元素的位置） |
| 希尔排序 | O(nlogn) | O(ns)(1<s<2) | 不稳定 | O(1)       | s是所选分组                                  |
| 快速排序 | O(nlogn) | O(n2)        | 不稳定 | O(logn)    | n较大时好                                    |
| 归并排序 | O(nlogn) | O(nlogn)     | 稳定   | O(1)       | n较大时好                                    |
| 堆排序   | O(nlogn) | O(nlogn)     | 不稳定 | O(1)       | n较大时好                                    |

### 4. [冒泡排序](./BubbleSorting.java)

算法步骤：

- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。

- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

- 针对所有的元素重复以上的步骤，除了最后一个。

- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

- 一共进行了数组元素个数-1次大循环，且每次大循环中需要比较的元素越来越少。

- 优化：如果在某次大循环，发现没有发生交换，则证明已经有序。

### 5. [选择排序](./SelectSorting.java)

算法步骤：

- 遍历整个数组，找到最小（大）的元素，放到数组的起始位置。

- 再遍历剩下的数组，找到剩下元素中的最小（大）元素，放到数组的第二个位置。

- 重复以上步骤，直到排序完成。

- 一共需要遍历数组元素个数-1次，当找到第二大（小）的元素时，可以停止。这时最后一个元素必是最大（小）元素。

### 6. [插入排序](./InsertSorting.java)

算法步骤:

- 将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

- 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。

### 7. [希尔排序](./InsertSorting.java)

>当插入排序最后一个元素为整个数组的最小元素时，需要将前面的有序数组中的每个元素都向后移一位，这样是非常花时间的。
所以有了希尔排序来帮我们将数组从无序变为整体有序再变为有序。

算法步骤:

- 选择一个增量序列t1（一般是数组长度/2），t2（一般是一个分组长度/2），……，tk，其中 ti > tj, tk = 1；

- 按增量序列个数 k，对序列进行 k 趟排序；

- 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

![在这里插入图片描述](../../../../resources/picture/希尔排序图解.png)

### 7. [快速排序](./QuickSorting.java)

算法步骤:

- 先从数列中取出一个数作为基准数（pivot）。

- 分区（partition）过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。

- 再对左右区间递归地（recursive）重复第二步，直到各区间只有一个数。

### 8. [归并排序](./MergeSorting.java)  

### 9. [基数排序](./RadixSorting.java)  