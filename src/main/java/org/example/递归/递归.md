# 递归

### 1.概念

递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。并且递归用到了虚拟机栈


### 2.能解决的问题
数学问题
- [八皇后问题](./Queue8.java)
- 汉诺塔
- 求阶乘
- [迷宫问题](./MiGong.java)
- 球和篮子

各种排序算法

### 3.规则
 
- 方法的变量是独立的，不会相互影响的

- 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据

- 递归必须向退出递归的条件逼近，否则就是无限递归，出现 StackOverflowError

- 当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕

### 4.迷宫问题
**思路：**

- 用一个二维矩阵代表地图
  - 1代表边界
  - 0代表未做过该地点
  - 2代表走过且能走得通
  - 3代表走过但走不通
- 设置起点和终点以及每个地点的行走策略
  - 行走策略指在该点所走的方向的顺序，如 右->下->左->上（调用寻找路径的方法，使用递归）
- 每次行走时假设该点能够走通，然后按照策略去判断，如果所有策略判断后都走不通，则该点走不通
  图解

初始地图
```java
当前地图情况：
1  1  1  1  1  1  1
1  0  0  0  0  0  1
1  0  0  0  0  0  1
1  1  1  0  0  0  1
1  0  0  0  0  0  1
1  0  0  0  0  0  1
1  0  0  0  0  0  1
1  1  1  1  1  1  1  
```
策略：[下右上左](./MiGong.java)

行进轨迹：
```java
是否找到终点：true
走过并标识后的路径：
1  1  1  1  1  1  1  
1  2  0  0  0  0  1  
1  2  2  2  0  0  1  
1  1  1  2  0  0  1  
1  0  0  2  0  0  1  
1  0  0  2  0  0  1  
1  0  0  2  2  2  1  
1  1  1  1  1  1  1
```

### 5.八皇后问题
八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在 8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法(92)。

**思路：**
- 将第一个皇后放在第一行第一列

- 将第二个皇后放在第二行第一列，判断是否会和其他皇后相互攻击，若会相互攻击，则将其放到第三列、第四列…知道不会相互攻击为止

- 将第三个皇后放在第三行第一列，判断是否会和其他皇后相互攻击，若会相互攻击，则将其放到第三列、第四列…知道不会相互攻击为止，并以此类推，在摆放的过程中，有可能会改动前面所放的皇后的位置

- 当得到一个正确的解时，就会回溯到上一行，由此来找出第一个皇后在第一行第一列的所有解

- 再将第一个皇后放到第一行第二列，并重复以上四个步骤

- 注意：
  - 棋盘本身应该是用二维数组表示，但是因为皇后所在的行数是固定的，所以可以简化为用一个一维数组来表示。其中的值代表皇后所在的列
  - 数组下标代表皇后所在行数，所以判断是否在同一行列斜线上时，只需要判断是否在同一列和同一斜线上即可
    - 是否同列判断：值是否相同
    - 是否同一斜线：行号-行号是否等于列号-列号，且列号相减要取绝对值

[八皇后问题模拟代码](./Queue8.java)

运行结果：
```java
0 4 7 5 2 6 1 3
0 5 7 2 6 3 1 4
0 6 3 5 7 1 4 2
0 6 4 7 1 3 5 2
1 3 5 7 2 0 6 4
1 4 6 0 2 7 5 3
1 4 6 3 0 7 5 2
1 5 0 6 3 7 2 4
1 5 7 2 0 3 6 4
1 6 2 5 7 4 0 3
1 6 4 7 0 3 5 2
1 7 5 0 2 4 6 3
2 0 6 4 7 1 3 5
2 4 1 7 0 6 3 5
2 4 1 7 5 3 6 0
2 4 6 0 3 1 7 5
2 4 7 3 0 6 1 5
2 5 1 4 7 0 6 3
2 5 1 6 0 3 7 4
2 5 1 6 4 0 7 3
2 5 3 0 7 4 6 1
2 5 3 1 7 4 6 0
2 5 7 0 3 6 4 1
2 5 7 0 4 6 1 3
2 5 7 1 3 0 6 4
2 6 1 7 4 0 3 5
2 6 1 7 5 3 0 4
2 7 3 6 0 5 1 4
3 0 4 7 1 6 2 5
3 0 4 7 5 2 6 1
3 1 4 7 5 0 2 6
3 1 6 2 5 7 0 4
3 1 6 2 5 7 4 0
3 1 6 4 0 7 5 2
3 1 7 4 6 0 2 5
3 1 7 5 0 2 4 6
3 5 0 4 1 7 2 6
3 5 7 1 6 0 2 4
3 5 7 2 0 6 4 1
3 6 0 7 4 1 5 2
3 6 2 7 1 4 0 5
3 6 4 1 5 0 2 7
3 6 4 2 0 5 7 1
3 7 0 2 5 1 6 4
3 7 0 4 6 1 5 2
3 7 4 2 0 6 1 5
4 0 3 5 7 1 6 2
4 0 7 3 1 6 2 5
4 0 7 5 2 6 1 3
4 1 3 5 7 2 0 6
4 1 3 6 2 7 5 0
4 1 5 0 6 3 7 2
4 1 7 0 3 6 2 5
4 2 0 5 7 1 3 6
4 2 0 6 1 7 5 3
4 2 7 3 6 0 5 1
4 6 0 2 7 5 3 1
4 6 0 3 1 7 5 2
4 6 1 3 7 0 2 5
4 6 1 5 2 0 3 7
4 6 1 5 2 0 7 3
4 6 3 0 2 7 5 1
4 7 3 0 2 5 1 6
4 7 3 0 6 1 5 2
5 0 4 1 7 2 6 3
5 1 6 0 2 4 7 3
5 1 6 0 3 7 4 2
5 2 0 6 4 7 1 3
5 2 0 7 3 1 6 4
5 2 0 7 4 1 3 6
5 2 4 6 0 3 1 7
5 2 4 7 0 3 1 6
5 2 6 1 3 7 0 4
5 2 6 1 7 4 0 3
5 2 6 3 0 7 1 4
5 3 0 4 7 1 6 2
5 3 1 7 4 6 0 2
5 3 6 0 2 4 1 7
5 3 6 0 7 1 4 2
5 7 1 3 0 6 4 2
6 0 2 7 5 3 1 4
6 1 3 0 7 4 2 5
6 1 5 2 0 3 7 4
6 2 0 5 7 4 1 3
6 2 7 1 4 0 5 3
6 3 1 4 7 0 2 5
6 3 1 7 5 0 2 4
6 4 2 0 5 7 1 3
7 1 3 0 6 4 2 5
7 1 4 2 0 6 3 5
7 2 0 5 1 4 6 3
7 3 0 2 5 1 6 4
共有92种解法！
```